<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<title>Tabs</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@12/swiper-bundle.min.css" />
	<script src="https://cdn.jsdelivr.net/npm/swiper@12/swiper-bundle.min.js"></script>
	<style>
		:root {
			--primary: #0d6efd;
			--secondary: #6c757d;
			--success: #198754;
			--info: #0dcaf0;
			--warning: #ffc107;
			--danger: #dc3545;
			--light: #dee2e6;
			--dark: #212529;
		}
		/* http://meyerweb.com/eric/tools/css/reset/ 
			v2.0 | 20110126
			License: none (public domain)
		*/

		html, body, div, span, applet, object, iframe,
		h1, h2, h3, h4, h5, h6, p, blockquote, pre,
		a, abbr, acronym, address, big, cite, code,
		del, dfn, em, img, ins, kbd, q, s, samp,
		small, strike, strong, sub, sup, tt, var,
		b, u, i, center,
		dl, dt, dd, ol, ul, li,
		fieldset, form, label, legend,
		table, caption, tbody, tfoot, thead, tr, th, td,
		article, aside, canvas, details, embed, 
		figure, figcaption, footer, header, hgroup, 
		menu, nav, output, ruby, section, summary,
		time, mark, audio, video {
			margin: 0;
			padding: 0;
			border: 0;
			font-size: 100%;
			font: inherit;
			vertical-align: baseline;
		}
		/* HTML5 display-role reset for older browsers */
		article, aside, details, figcaption, figure, 
		footer, header, hgroup, menu, nav, section {
			display: block;
		}
		ol, ul {
			list-style: none;
		}
		blockquote, q {
			quotes: none;
		}
		blockquote:before, blockquote:after,
		q:before, q:after {
			content: '';
			content: none;
		}
		table {
			border-collapse: collapse;
			border-spacing: 0;
		}
		

		
		body {
			font-family: 'Noto Sans KR', Arial, sans-serif; color: #000; line-height:1.4;
		}

		#header {
			position: fixed;
			top: 0;
			z-index: 1000;
			width: 100%;
			height: 60px;
			background-color: #3498db;
		}

		#container {
			position: relative;
			z-index: 500;
			padding: 60px 20px 20px;
		}

		.tab-container {
			margin: 0 auto;
			border-radius: 10px;
		}

		.tab {
			position: relative;
			z-index:100;
		}

		.tab-content .tab {
			z-index: 90;
		}

		.tab-indicator {
			position: absolute;
			left: 0;
			bottom: 0;
			height: 2px;
			background: var(--primary);
			transition: all 0.3s cubic-bezier(.4, 0, .2, 1);
			width: 0;
			z-index: 2;
		}

		.tab_group {
			position: relative;
			display: flex;
			border-bottom: 1px solid var(--light);
		}

		.tab_item {
			flex: 1;
		}

		.tab_btn {
			display: flex;
			justify-content: center;
			width: 100%;
			padding: 15px;
			background-color: transparent;
			text-align: center;
			border: none;
			cursor: pointer;
			font-size: 16px;
			white-space: nowrap;
			font-weight: 400;
		}


		.tab_btn.active {
			font-weight: 700;
		}

		.tab-pane {
			display: none;
			margin-top: 28px;
			padding: 20px;
			height: 1000px;
			border-bottom:1px solid var(--secondary);
		}

		.tab-pane.active {
			display: block;
		}

		/* 탭 - fixed */
		.tab-container[data-tab-pos="fixed"] > .tab {
			position: fixed;
			top: 60px;
			width:100%;
			background-color: white;
		}
		.tab-container[data-tab-pos="fixed"] > .tab-content {
			padding-top:56px;
		}

		/* 탭 - sticky */
		.tab-container[data-tab-pos="sticky"] > .tab {
			position: sticky;
			top: 120px;
			background-color: white;
		}

		.tab-container[data-tab-pos="sticky"] > .tab-content .tab-pane {
			height: 100px;
		}

		/* 탭 - 사이즈 */
		.tab-container[data-tab-size="small"] > .tab .tab_item {
			flex: none;
		}

		/* 탭 - swiper */
		.tab-container[data-tab-swiper] > .tab {
			overflow: hidden;
		}

		.tab-container[data-tab-swiper] > .tab .tab-indicator {
			display: none;
		}

		.tab-container[data-tab-swiper] > .tab .tab_btn.active {
			border-bottom:2px solid #3498db;
		}
	</style>
</head>

<body>
	<header id="header">Header</header>
	<div id="container">
		<!-- 일반 탭 -->
		<div class="tab-container" data-tab-scroll data-tab-pos="fixed">
			<div class="tab" role="tablist">
				<ul class="tab_group">
					<li class="tab_item"><button class="tab_btn" id="tab_btn_1_1" aria-controls="tab1_1" role="tab">콘텐츠 전체 탭1</button></li>
					<li class="tab_item"><button class="tab_btn" id="tab_btn_1_2" aria-controls="tab1_2" role="tab">콘텐츠 전체 탭2</button></li>
					<li class="tab_item"><button class="tab_btn" id="tab_btn_1_3" aria-controls="tab1_3" role="tab">콘텐츠 전체 탭3</button></li>
				</ul>
				<div class="tab-indicator"></div>
			</div>
			<div class="tab-content">
				<div id="tab1_1" class="tab-pane" role="tabpanel">
					<h2>dsfsd</h2>
					<div class="tab-container" data-tab-swiper>
						<div class="tab" role="tablist">
							<div class="tab_group">
								<div class="tab_item"><button class="tab_btn" id="tab_btn_3_1" aria-controls="tab3_1" role="tab">Tab1Tab1Tab1Tab1Tab1Tab1</button></div>
								<div class="tab_item"><button class="tab_btn" id="tab_btn_3_2" aria-controls="tab3_2" role="tab">Tab2Tab2Tab2Tab2Tab2</button></div>
								<div class="tab_item"><button class="tab_btn" id="tab_btn_3_3" aria-controls="tab3_3" role="tab">Tab3Tab3Tab3Tab3Tab3</button></div>
							</div>
							<div class="tab-indicator"></div>
						</div>
						<div class="tab-content">
							<div id="tab3_1" class="tab-pane" role="tabpanel">
								<h2>Tab 1 Content</h2>
							</div>
							<div id="tab3_2" class="tab-pane" role="tabpanel">
								<h2>Tab 2 Content</h2>
							</div>
							<div id="tab3_3" class="tab-pane" role="tabpanel">
								<h2>Tab 3 Content</h2>
							</div>
						</div>
					</div>

					<div class="tab-container" data-tab-size="small" data-tab-pos="sticky">
						<div class="tab" role="tablist">
							<div class="tab_group">
								<div class="tab_item"><button class="tab_btn" id="tab_btn_4_1" aria-controls="tab4_1" role="tab">탭1</button></div>
								<div class="tab_item"><button class="tab_btn" id="tab_btn_4_2" aria-controls="tab4_2" role="tab">탭2</button></div>
								<div class="tab_item"><button class="tab_btn" id="tab_btn_4_3" aria-controls="tab4_3" role="tab">탭3</button></div>
								<div class="tab_item"><button class="tab_btn" id="tab_btn_4_4" aria-controls="tab4_4" role="tab">탭4</button></div>
							</div>
							<div class="tab-indicator"></div>
						</div>
						<div class="tab-content">
							<div id="tab4_1" class="tab-pane" role="tabpanel">
								<h2>Tab 1 Content</h2>
							</div>
							<div id="tab4_2" class="tab-pane" role="tabpanel">
								<h2>Tab 2 Content</h2>
							</div>
							<div id="tab4_3" class="tab-pane" role="tabpanel">
								<h2>Tab 3 Content</h2>
							</div>
							<div id="tab4_4" class="tab-pane" role="tabpanel">
								<h2>Tab 4 Content</h2>
							</div>
						</div>
					</div>
				</div>
				<div id="tab1_2" class="tab-pane" role="tabpanel">
					
				</div>
				<div id="tab1_3" class="tab-pane" role="tabpanel">
					<h2>Tab 3 Content</h2>
				</div>
			</div>
		</div>
	</div>
	<script>
		const UI = {
			common: {
				/**
				 * 요소의 offsetHeight 반환 (선택자 또는 요소)
				 * @param {string|HTMLElement|null} target - 선택자 문자열 또는 DOM 요소
				 * @returns {number}
				 */
				getOffsetHeight(target) {
					let el = null;

					if (typeof target === 'string') {
						el = document.querySelector(target);
					} else if (target instanceof HTMLElement) {
						el = target;
					}

					return el ? el.offsetHeight : 0;
				},
				/**
				 * 스크롤 이동 후 콜백 실행 (jQuery animate 대체)
				 * @param {number} targetY - 이동할 Y 위치
				 * @param {number} duration - 애니메이션 시간 (ms)
				 * @param {Function} callback - 완료 후 실행할 콜백
				 */
				scrollToWithCallback(targetY, duration = 500, callback) {
					const start = window.scrollY || window.pageYOffset;
					const startTime = performance.now();

					function scroll() {
						const now = performance.now();
						const time = Math.min(1, (now - startTime) / duration);
						const easeOut = time * (2 - time); // easeOutQuad
						window.scrollTo(0, Math.ceil((easeOut * (targetY - start)) + start));

						if (time < 1) {
							requestAnimationFrame(scroll);
						} else if (typeof callback === 'function') {
							callback(); // 스크롤 완료 후 실행
						}
					}

					requestAnimationFrame(scroll);
				}
			},
			tab : {
				// 스크롤 위치 인식 허용 오차 (px)
				SCROLL_THRESHOLD: 10,
				// 스크롤 이벤트 throttle 지연시간 (ms)
				THROTTLE_DELAY: 100,

				/**
				 * throttle 함수: 특정 시간 간격으로만 콜백 실행
				 * @param {Function} fn 실행할 함수
				 * @param {number} wait 대기 시간 (밀리초)
				 * @returns {Function} throttle된 함수
				 */
				throttle(fn, wait) {
					let lastTime = 0;
					return function (...args) {
						const now = Date.now();
						if (now - lastTime >= wait) {
							lastTime = now;
							fn.apply(this, args);
						}
					};
				},

				/**
				 * 페이지 내 모든 탭 컨테이너 초기화
				 */
				initAll() {
					const containers = document.querySelectorAll('.tab-container');
					containers.forEach(container => this.init(container));
				},

				/**
				 * 개별 탭 컨테이너 초기화
				 * @param {HTMLElement} container 탭 컨테이너 요소
				 */
				init(container) {
					if (!container) return;

					const isScrollTab = container.hasAttribute('data-tab-scroll'); // 스크롤 연동 탭 여부
					const tabGroup = container.querySelector('.tab'); // 탭 버튼 그룹 컨테이너
					const tabsBtn = container.querySelector('.tab').querySelectorAll('.tab_btn'); // 개별 탭 버튼들
					const tabContent = container.querySelector('.tab-content');
					const tabPanes = tabContent ? Array.from(tabContent.children).filter(el => el.classList.contains('tab-pane')) : []; // 탭 내용 패널들
					const indicator = container.querySelector('.tab-indicator'); // 하단 이동 표시 

					if (!tabsBtn.length || !tabPanes.length) return; // 탭 또는 패널 없으면 종료

					// 스크롤 연동 탭이면 모든 패널 항상 표시 (숨기지 않음)
					if (isScrollTab) {
						tabPanes.forEach(pane => {
							pane.classList.add('active');
						});
					}

					// swiper가 필요한 경우 초기화하고 swiper 인스턴스 반환
					const swiperInstance = this.initSwiper(container, tabGroup);

					// 키보드 네비게이션 이벤트 위임 설정 (컨테이너 단위)
					this.setupKeyboardNavigation(tabsBtn, container);

					// 클릭 이벤트 위임 설정
					this.setupClickHandler(container, tabsBtn, tabPanes, indicator, isScrollTab, swiperInstance);

					// 첫 번째 탭 활성화 (초기 상태)
					this.activateTab(tabsBtn, tabPanes, 2, indicator, isScrollTab);
				},

				/**
				 * Swiper 초기화 함수
				 * - data-tab-swiper 속성이 있는 경우 자동으로 swiper 관련 클래스 추가 및 Swiper 인스턴스 초기화
				 * @param {HTMLElement} container 탭 컨테이너 요소
				 * @param {HTMLElement} tabGroup 탭 버튼 그룹 요소 (.tab)
				 * @returns {Swiper|null} Swiper 인스턴스 또는 null
				 */
				initSwiper(container, tabGroup) {
					// swiper 활성화 조건 확인: data-tab-swiper 속성이 없으면 처리하지 않음
					if (!container.hasAttribute('data-tab-swiper')) return null;

					// 1. 탭 버튼 그룹 (.tab_group) 찾기
					const tabsGroup = tabGroup.querySelector('.tab_group');

					// 2. .tabs_group에 swiper-wrapper 클래스 자동 추가
					if (tabsGroup && !tabsGroup.classList.contains('swiper-wrapper')) {
						tabsGroup.classList.add('swiper-wrapper');
					}

					// 3. 각 탭 항목 (.tab_item)에 swiper-slide 클래스 자동 추가
					const tabItems = tabsGroup ? tabsGroup.querySelectorAll('.tab_item') : [];
					tabItems.forEach(item => {
						if (!item.classList.contains('swiper-slide')) {
							item.classList.add('swiper-slide');
						}
					});

					// 5. Swiper 인스턴스 생성
					const swiper = new Swiper(tabGroup, {
						slidesPerView: 'auto', // 자동 너비 슬라이드 (탭 개수/길이 따라감)
						// 추가 옵션 필요 시 여기에 작성 가능 (예: spaceBetween, loop 등)
					});

					// 6. 컨테이너에 swiper 인스턴스 저장 (재사용 목적)
					container._swiperInstance = swiper;

					// 7. 생성된 인스턴스 반환
					return swiper;
				},


				/**
				 * 탭 활성화 함수 - 버튼과 패널 상태를 동기화
				 * @param {NodeListOf<HTMLElement>} tabsBtn 탭 버튼 리스트
				 * @param {NodeListOf<HTMLElement>} panes 탭 내용 패널 리스트
				 * @param {number} idx 활성화할 탭 인덱스
				 * @param {HTMLElement|null} indicator 하단 활성 표시 요소
				 * @param {boolean} isScrollTab 스크롤 연동 탭인지 여부
				 */
				activateTab(tabsBtn, panes, idx, indicator, isScrollTab = false) {
					tabsBtn.forEach((tabBtn, i) => {
						const isActive = i === idx;
						tabBtn.classList.toggle('active', isActive);
						tabBtn.setAttribute('aria-selected', isActive ? 'true' : 'false'); // 접근성용 aria-selected 설정
						tabBtn.setAttribute('tabindex', isActive ? '0' : '-1'); // 포커스 순서 관리
					});

					panes.forEach((pane, i) => {
						if (!isScrollTab) {
							// 일반 탭 - 선택된 페인만 보이도록 설정
							pane.classList.toggle('active', i === idx);
							pane.hidden = i !== idx;
							pane.setAttribute('aria-hidden', i !== idx ? 'true' : 'false');
						} else {
							// 스크롤 연동 탭은 항상 보임, aria-hidden 속성만 설정
							pane.setAttribute('aria-hidden', 'false');
						}
					});

					if (indicator && tabsBtn[idx]) {
						const tabBtn = tabsBtn[idx];
						// 하단 표시바 위치와 너비 변경 (애니메이션 효과 있음)
						indicator.style.width = `${tabBtn.offsetWidth}px`;
						indicator.style.left = `${tabBtn.offsetLeft}px`;
					}
				},

				/**
				 * Swiper 슬라이드 이동 함수
				 * @param {Swiper|null} swiperInstance swiper 인스턴스
				 * @param {number} idx 이동할 슬라이드 인덱스
				 */
				slideToSwiper(swiperInstance, idx, tabsBtn) {
					if (swiperInstance) {
						swiperInstance.slideTo(idx);
					}
				},

				/**
				 * 키보드 네비게이션 (화살표, 엔터/스페이스) 이벤트 위임 설정
				 * @param {NodeListOf<HTMLElement>} tabsBtn 탭 버튼 리스트
				 * @param {HTMLElement} container 탭 컨테이너 요소
				 */
				setupKeyboardNavigation(tabsBtn, container) {
					container.addEventListener('keydown', (e) => {
						const target = e.target;
						// 탭 버튼에서만 동작
						if (!target.classList.contains('tab_btn')) return;

						const tabsArray = Array.from(tabsBtn);
						const idx = tabsArray.indexOf(target);
						if (idx === -1) return;

						let newIdx = idx;

						if (e.key === 'ArrowRight') {
							e.preventDefault();
							newIdx = (idx + 1) % tabsArray.length; // 오른쪽 화살표: 다음 탭으로 이동 (순환)
							tabsArray[newIdx].focus();
						} else if (e.key === 'ArrowLeft') {
							e.preventDefault();
							newIdx = (idx - 1 + tabsArray.length) % tabsArray.length; // 왼쪽 화살표: 이전 탭으로 이동 (순환)
							tabsArray[newIdx].focus();
						} else if (e.key === 'Enter' || e.key === ' ') {
							e.preventDefault();
							target.click(); // 엔터나 스페이스 누르면 해당 탭 클릭 이벤트 발생
						}
					});
				},

				/**
				 * 클릭 이벤트 위임 설정
				 * @param {HTMLElement} container 탭 컨테이너 요소
				 * @param {NodeListOf<HTMLElement>} tabsBtn 탭 버튼 리스트
				 * @param {NodeListOf<HTMLElement>} tabPanes 탭 내용 패널 리스트
				 * @param {HTMLElement|null} indicator 하단 활성 표시 요소
				 * @param {boolean} isScrollTab 스크롤 연동 탭 여부
				 * @param {Swiper|null} swiperInstance swiper 인스턴스
				 */
				setupClickHandler(container, tabsBtn, tabPanes, indicator, isScrollTab, swiperInstance) {
					const tabsGroup = tabsBtn[0].closest('.tab');
					const tabsHeight = tabsGroup ? tabsGroup.offsetHeight : 0;

					// 스크롤 연동 탭일 경우 스크롤 상태 관리용 객체
					let scrollState = {
						isScrollingByClick: false,
						scrollTargetIdx: null,
					};

					// 컨테이너 단위 클릭 이벤트 위임
					container.addEventListener('click', (e) => {
						const target = e.target;
						if (!target.classList.contains('tab_btn')) return;

						const tabsArray = Array.from(tabsBtn);
						const idx = tabsArray.indexOf(target);
						if (idx === -1) return;

						if (isScrollTab) {
							// 스크롤 연동 탭 클릭 시 스크롤 이동 트리거 및 상태 갱신
							scrollState.isScrollingByClick = true;
							scrollState.scrollTargetIdx = idx;

							const pane = tabPanes[idx];
							const paneRect = pane.getBoundingClientRect();
							const scrollY = window.scrollY || window.pageYOffset;
							const offset = UI.common.getOffsetHeight('header'); // fixed header 높이 보정 포함
							const targetY = paneRect.top + scrollY - tabsHeight - offset; // 탭 높이만큼 오프셋 보정

							// 스크롤 이동 전 활성화
							// this.activateTab(tabsBtn, tabPanes, idx, indicator, true);
							// this.slideToSwiper(swiperInstance, idx);
							
							UI.common.scrollToWithCallback(targetY, 500, () => {
								// 스크롤 이동 후 활성화
								this.activateTab(tabsBtn, tabPanes, idx, indicator, true);
								this.slideToSwiper(swiperInstance, idx);

								if (typeof window.onTabScrollComplete === 'function') {
									window.onTabScrollComplete(idx, pane);
								}

								// 스크롤 상태 초기화
								scrollState.isScrollingByClick = false;
								scrollState.scrollTargetIdx = null;
							});
						} else {
							// 일반 탭 클릭 시 즉시 탭 활성화
							this.activateTab(tabsBtn, tabPanes, idx, indicator);
							this.slideToSwiper(swiperInstance, idx);
						}
					});

					// 스크롤 이벤트를 throttle 적용해서 등록 (스크롤 연동 탭에만)
					if (isScrollTab) {
						window.addEventListener(
							'scroll',
							this.throttle(() => {
								this.handleScrollNavigation(tabsBtn, tabPanes, indicator, scrollState, swiperInstance);
							}, this.THROTTLE_DELAY)
						);
					}
				},

				/**
				 * 스크롤 위치에 따른 탭 활성화 처리 함수
				 * @param {NodeListOf<HTMLElement>} tabsBtn 탭 버튼 리스트
				 * @param {NodeListOf<HTMLElement>} panes 탭 내용 패널 리스트
				 * @param {HTMLElement|null} indicator 하단 활성 표시 요소
				 * @param {Object} scrollState 스크롤 상태 객체
				 * @param {Swiper|null} swiperInstance swiper 인스턴스 (추가)
				 */
				handleScrollNavigation(tabsBtn, panes, indicator, scrollState, swiperInstance) {
					const { isScrollingByClick, scrollTargetIdx } = scrollState;
					const tabsEl = tabsBtn[0].closest('.tab-container').querySelector('.tab');
					const tabsHeight = tabsEl ? tabsEl.offsetHeight : 0;

					// 클릭에 의한 스크롤 이동 중이면, 목표 위치 근처 도달 여부 체크
					if (isScrollingByClick && scrollTargetIdx !== null) {
						const pane = panes[scrollTargetIdx];
						const paneTop = pane.getBoundingClientRect().top;
						if (Math.abs(paneTop - tabsHeight) <= this.SCROLL_THRESHOLD) {
							// 목표 위치 도달하면 스크롤 이동 상태 초기화
							scrollState.isScrollingByClick = false;

							// swiper도 해당 탭으로 슬라이드 이동 추가
							this.slideToSwiper(swiperInstance, scrollTargetIdx);

							// 외부 콜백 함수 호출 (존재 시)
							if (typeof window.onTabScrollComplete === 'function') {
								window.onTabScrollComplete(scrollTargetIdx, pane);
							}

							scrollState.scrollTargetIdx = null;
							// 탭 활성화 상태 재설정 (aria 등 갱신)
							this.activateTab(tabsBtn, panes, scrollTargetIdx, indicator, true);
						}
						return; // 클릭 스크롤 중엔 아래 일반 스크롤 처리 로직 건너뜀
					}

					// 클릭 이동이 아닐 때는 현재 스크롤 위치에 가장 가까운 패널 찾기
					let foundIdx = 0;
					let minDiff = Infinity;
					const tabsBottom = tabsEl.getBoundingClientRect().bottom;

					panes.forEach((pane, idx) => {
						const rect = pane.getBoundingClientRect();
						const diff = Math.abs(rect.top - tabsBottom);
						// 탭 하단 근처 위치를 기준으로 가장 가까운 패널 선택
						if (rect.top - tabsBottom <= this.SCROLL_THRESHOLD && diff < minDiff) {
							minDiff = diff;
							foundIdx = idx;
						}
					});

					// 스크롤 위치 기준으로 탭 활성화 갱신
					this.activateTab(tabsBtn, panes, foundIdx, indicator, true);

					// swiper 슬라이드 위치도 갱신 (추가)
					this.slideToSwiper(swiperInstance, foundIdx);
				},
			}
		}

		// DOMContentLoaded 이벤트에 탭 UI 초기화 및 스크롤 완료 콜백 정의
		document.addEventListener('DOMContentLoaded', () => {
			UI.tab.initAll();

			// 스크롤 완료 후 첫 자식 요소에 tabindex 0 부여 및 포커스 이동 (접근성 보완)
			window.onTabScrollComplete = function (tabIndex, pane) {
				const firstTag = pane.firstElementChild;
				if (firstTag) {
					firstTag.setAttribute('tabindex', 0);
					firstTag.focus();
				}
			};
		});
	</script>


</body>

</html>
