<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<title>Tabs</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700;900&display=swap">
	<link rel="stylesheet" href="./css/common.css">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@12/swiper-bundle.min.css" />
	<script src="https://cdn.jsdelivr.net/npm/swiper@12/swiper-bundle.min.js"></script>
</head>

<body>
	<div id="wrap">
		<header id="header">Header</header>
		<section id="container">
			<!-- 일반 탭 -->
			<div class="tab" data-tab-scroll data-tab-pos="fixed">
				<div class="tab_container" role="tablist">
					<ul class="tab_group">
						<li class="tab_item"><button id="tab_btn1_1" class="tab_btn" role="tab" aria-controls="tab_pane1_1">콘텐츠 전체 탭1</button></li>
						<li class="tab_item"><button id="tab_btn1_2" class="tab_btn" role="tab" aria-controls="tab_pane1_2">콘텐츠 전체 탭2</button></li>
						<li class="tab_item"><button id="tab_btn1_3" class="tab_btn" role="tab" aria-controls="tab_pane1_3">콘텐츠 전체 탭3</button></li>
					</ul>
					<div class="tab_indicator"></div>
				</div>
				<div class="tab_content">
					<div id="tab_pane1_1" class="tab_pane" role="tabpanel" aria-labelledby="tab_btn1_1">
						<h2>dsfsd</h2>
						<div class="tab" data-tab-swiper>
							<div class="tab_container" role="tablist">
								<div class="tab_group">
									<div class="tab_item"><button id="tab_btn2_1" class="tab_btn" role="tab" aria-controls="tab_pane2_1">Tab1Tab1Tab1Tab1Tab1Tab1</button></div>
									<div class="tab_item"><button id="tab_btn2_2" class="tab_btn" role="tab" aria-controls="tab_pane2_2">Tab2Tab2Tab2Tab2Tab2</button></div>
									<div class="tab_item"><button id="tab_btn2_3" class="tab_btn" role="tab" aria-controls="tab_pane2_3">Tab3Tab3Tab3Tab3Tab3</button></div>
								</div>
								<div class="tab_indicator"></div>
							</div>
							<div class="tab_content">
								<div id="tab_pane2_1" class="tab_pane" role="tabpanel" aria-labelledby="tab_btn2_1">
									<h2>Tab 1 Content</h2>
								</div>
								<div id="tab_pane2_2" class="tab_pane" role="tabpanel" aria-labelledby="tab_btn2_2">
									<h2>Tab 2 Content</h2>
								</div>
								<div id="tab_pane2_3" class="tab_pane" role="tabpanel" aria-labelledby="tab_btn2_3">
									<h2>Tab 3 Content</h2>
								</div>
							</div>
						</div>

						<div class="tab" data-tab-size="small" data-tab-pos="sticky">
							<div class="tab_container" role="tablist">
								<div class="tab_group">
									<div class="tab_item"><button id="tab_btn3_1" class="tab_btn" role="tab" aria-controls="tab_pane3_1">탭1</button></div>
									<div class="tab_item"><button id="tab_btn3_2" class="tab_btn" role="tab" aria-controls="tab_pane3_2">탭2</button></div>
									<div class="tab_item"><button id="tab_btn3_3" class="tab_btn" role="tab" aria-controls="tab_pane3_3">탭3</button></div>
									<div class="tab_item"><button id="tab_btn3_4" class="tab_btn" role="tab" aria-controls="tab_pane3_4">탭4</button></div>
								</div>
								<div class="tab_indicator"></div>
							</div>
							<div class="tab_content">
								<div id="tab_pane3_1" class="tab_pane" role="tabpanel" aria-labelledby="tab_btn3_1">
									<h2>Tab 1 Content</h2>
								</div>
								<div id="tab_pane3_2" class="tab_pane" role="tabpanel" aria-labelledby="tab_btn3_2">
									<h2>Tab 2 Content</h2>
								</div>
								<div id="tab_pane3_3" class="tab_pane" role="tabpanel" aria-labelledby="tab_btn3_3">
									<h2>Tab 3 Content</h2>
								</div>
								<div id="tab_pane3_4" class="tab_pane" role="tabpanel" aria-labelledby="tab_btn3_4">
									<h2>Tab 4 Content</h2>
								</div>
							</div>
						</div>
					</div>
					<div id="tab_pane1_2" class="tab_pane" role="tabpanel" aria-labelledby="tab_btn1_2">
					</div>
					<div id="tab_pane1_3" class="tab_pane" role="tabpanel" aria-labelledby="tab_btn1_3">
						<h2>Tab 3 Content</h2>
					</div>
				</div>
			</div>
		</section>
	</div>
	<script>
		const UI = {
			common: {
				/**
				 * 요소의 offsetHeight 반환 (선택자 또는 요소)
				 * @param {string|HTMLElement|null} target - 선택자 문자열 또는 DOM 요소
				 * @returns {number}
				 */
				getOffsetHeight(target) {
					let el = null;

					if (typeof target === 'string') {
						el = document.querySelector(target);
					} else if (target instanceof HTMLElement) {
						el = target;
					}

					return el ? el.offsetHeight : 0;
				},
				/**
				 * 스크롤 이동 후 콜백 실행 (jQuery animate 대체)
				 * @param {number} targetY - 이동할 Y 위치
				 * @param {number} duration - 애니메이션 시간 (ms)
				 * @param {Function} callback - 완료 후 실행할 콜백
				 */
				scrollToWithCallback(targetY, duration = 500, callback) {
					const start = window.scrollY || window.pageYOffset;
					const startTime = performance.now();

					function scroll() {
						const now = performance.now();
						const time = Math.min(1, (now - startTime) / duration);
						const easeOut = time * (2 - time); // easeOutQuad
						window.scrollTo(0, Math.ceil((easeOut * (targetY - start)) + start));

						if (time < 1) {
							requestAnimationFrame(scroll);
						} else if (typeof callback === 'function') {
							callback(); // 스크롤 완료 후 실행
						}
					}

					requestAnimationFrame(scroll);
				}
			},
			tab : {
				// 스크롤 위치 인식 허용 오차 (px)
				SCROLL_THRESHOLD: 10,
				// 스크롤 이벤트 throttle 지연시간 (ms)
				THROTTLE_DELAY: 100,

				/**
				 * throttle 함수: 특정 시간 간격으로만 콜백 실행
				 * @param {Function} fn 실행할 함수
				 * @param {number} wait 대기 시간 (밀리초)
				 * @returns {Function} throttle된 함수
				 */
				throttle(fn, wait) {
					let lastTime = 0;
					return function (...args) {
						const now = Date.now();
						if (now - lastTime >= wait) {
							lastTime = now;
							fn.apply(this, args);
						}
					};
				},

				/**
				 * 페이지 내 모든 탭 컨테이너 초기화
				 */
				initAll() {
					const containers = document.querySelectorAll('.tab');
					containers.forEach(container => this.init(container));
				},

				/**
				 * 개별 탭 컨테이너 초기화
				 * @param {HTMLElement} container 탭 컨테이너 요소
				 */
				init(container) {
					if (!container) return;

					const isScrollTab = container.hasAttribute('data-tab-scroll'); // 스크롤 연동 탭 여부
					const tabContainer = container.querySelector('.tab_container'); // 탭 버튼 그룹 컨테이너
					const tabsBtns = container.querySelector('.tab_container').querySelectorAll('.tab_btn'); // 개별 탭 버튼들
					const tabContent = container.querySelector('.tab_content');
					const tabPanes = tabContent ? Array.from(tabContent.children).filter(el => el.classList.contains('tab_pane')) : []; // 탭 내용 패널들
					const tabIndicator = container.querySelector('.tab_indicator'); // 하단 이동 표시 

					if (!tabsBtns.length || !tabPanes.length) return; // 탭 또는 패널 없으면 종료

					// 스크롤 연동 탭이면 모든 패널 항상 표시 (숨기지 않음)
					if (isScrollTab) {
						tabPanes.forEach(pane => {
							pane.classList.add('active');
						});
					}

					// swiper가 필요한 경우 초기화하고 swiper 인스턴스 반환
					const swiperInstance = this.initSwiper(container, tabContainer);

					// 키보드 네비게이션 이벤트 위임 설정 (컨테이너 단위)
					this.setupKeyboardNavigation(tabsBtns, container);

					// 클릭 이벤트 위임 설정
					this.setupClickHandler(container, tabsBtns, tabPanes, tabIndicator, isScrollTab, swiperInstance);

					// 첫 번째 탭 활성화 (초기 상태)
					this.activateTab(tabsBtns, tabPanes, 2, tabIndicator, isScrollTab);
				},

				/**
				 * Swiper 초기화 함수
				 * - data-tab-swiper 속성이 있는 경우 자동으로 swiper 관련 클래스 추가 및 Swiper 인스턴스 초기화
				 * @param {HTMLElement} container 탭 컨테이너 요소
				 * @param {HTMLElement} tabContainer 탭 버튼 그룹 요소 (.tab_container)
				 * @returns {Swiper|null} Swiper 인스턴스 또는 null
				 */
				initSwiper(container, tabContainer) {
					// swiper 활성화 조건 확인: data-tab-swiper 속성이 없으면 처리하지 않음
					if (!container.hasAttribute('data-tab-swiper')) return null;

					// 1. 탭 버튼 그룹 (.tab_group) 찾기
					const tabsGroup = tabContainer.querySelector('.tab_group');

					// 2. .tabs_group에 swiper-wrapper 클래스 자동 추가
					if (tabsGroup && !tabsGroup.classList.contains('swiper-wrapper')) {
						tabsGroup.classList.add('swiper-wrapper');
					}

					// 3. 각 탭 항목 (.tab_item)에 swiper-slide 클래스 자동 추가
					const tabItems = tabsGroup ? tabsGroup.querySelectorAll('.tab_item') : [];
					tabItems.forEach(item => {
						if (!item.classList.contains('swiper-slide')) {
							item.classList.add('swiper-slide');
						}
					});

					// 5. Swiper 인스턴스 생성
					const swiper = new Swiper(tabContainer, {
						slidesPerView: 'auto', // 자동 너비 슬라이드 (탭 개수/길이 따라감)
						// 추가 옵션 필요 시 여기에 작성 가능 (예: spaceBetween, loop 등)
					});

					// 6. 컨테이너에 swiper 인스턴스 저장 (재사용 목적)
					container._swiperInstance = swiper;

					// 7. 생성된 인스턴스 반환
					return swiper;
				},


				/**
				 * 탭 활성화 함수 - 버튼과 패널 상태를 동기화
				 * @param {NodeListOf<HTMLElement>} tabsBtns 탭 버튼 리스트
				 * @param {NodeListOf<HTMLElement>} panes 탭 내용 패널 리스트
				 * @param {number} idx 활성화할 탭 인덱스
				 * @param {HTMLElement|null} tabIndicator 하단 활성 표시 요소
				 * @param {boolean} isScrollTab 스크롤 연동 탭인지 여부
				 */
				activateTab(tabsBtns, panes, idx, tabIndicator, isScrollTab = false) {
					tabsBtns.forEach((tabBtn, i) => {
						const isActive = i === idx;
						tabBtn.classList.toggle('active', isActive);
						tabBtn.setAttribute('aria-selected', isActive ? 'true' : 'false'); // 접근성용 aria-selected 설정
						tabBtn.setAttribute('tabindex', isActive ? '0' : '-1'); // 포커스 순서 관리
					});

					panes.forEach((pane, i) => {
						if (!isScrollTab) {
							// 일반 탭 - 선택된 페인만 보이도록 설정
							pane.classList.toggle('active', i === idx);
							pane.hidden = i !== idx;
							pane.setAttribute('aria-hidden', i !== idx ? 'true' : 'false');
						} else {
							// 스크롤 연동 탭은 항상 보임, aria-hidden 속성만 설정
							pane.setAttribute('aria-hidden', 'false');
						}
					});

					if (tabIndicator && tabsBtns[idx]) {
						const tabBtn = tabsBtns[idx];
						// 하단 표시바 위치와 너비 변경 (애니메이션 효과 있음)
						tabIndicator.style.width = `${tabBtn.offsetWidth}px`;
						tabIndicator.style.left = `${tabBtn.offsetLeft}px`;
					}
				},

				/**
				 * Swiper 슬라이드 이동 함수
				 * @param {Swiper|null} swiperInstance swiper 인스턴스
				 * @param {number} idx 이동할 슬라이드 인덱스
				 */
				slideToSwiper(swiperInstance, idx, tabsBtns) {
					if (swiperInstance) {
						swiperInstance.slideTo(idx);
					}
				},

				/**
				 * 키보드 네비게이션 (화살표, 엔터/스페이스) 이벤트 위임 설정
				 * @param {NodeListOf<HTMLElement>} tabsBtns 탭 버튼 리스트
				 * @param {HTMLElement} container 탭 컨테이너 요소
				 */
				setupKeyboardNavigation(tabsBtns, container) {
					container.addEventListener('keydown', (e) => {
						const target = e.target;
						// 탭 버튼에서만 동작
						if (!target.classList.contains('tab_btn')) return;

						const tabsArray = Array.from(tabsBtns);
						const idx = tabsArray.indexOf(target);
						if (idx === -1) return;

						let newIdx = idx;

						if (e.key === 'ArrowRight') {
							e.preventDefault();
							newIdx = (idx + 1) % tabsArray.length; // 오른쪽 화살표: 다음 탭으로 이동 (순환)
							tabsArray[newIdx].focus();
						} else if (e.key === 'ArrowLeft') {
							e.preventDefault();
							newIdx = (idx - 1 + tabsArray.length) % tabsArray.length; // 왼쪽 화살표: 이전 탭으로 이동 (순환)
							tabsArray[newIdx].focus();
						} else if (e.key === 'Enter' || e.key === ' ') {
							e.preventDefault();
							target.click(); // 엔터나 스페이스 누르면 해당 탭 클릭 이벤트 발생
						}
					});
				},

				/**
				 * 클릭 이벤트 위임 설정
				 * @param {HTMLElement} container 탭 컨테이너 요소
				 * @param {NodeListOf<HTMLElement>} tabsBtns 탭 버튼 리스트
				 * @param {NodeListOf<HTMLElement>} tabPanes 탭 내용 패널 리스트
				 * @param {HTMLElement|null} tabIndicator 하단 활성 표시 요소
				 * @param {boolean} isScrollTab 스크롤 연동 탭 여부
				 * @param {Swiper|null} swiperInstance swiper 인스턴스
				 */
				setupClickHandler(container, tabsBtns, tabPanes, tabIndicator, isScrollTab, swiperInstance) {
					const tabsGroup = tabsBtns[0].closest('.tab_container');
					const tabsHeight = tabsGroup ? tabsGroup.offsetHeight : 0;

					// 스크롤 연동 탭일 경우 스크롤 상태 관리용 객체
					let scrollState = {
						isScrollingByClick: false,
						scrollTargetIdx: null,
					};

					// 컨테이너 단위 클릭 이벤트 위임
					container.addEventListener('click', (e) => {
						const target = e.target;
						if (!target.classList.contains('tab_btn')) return;

						const tabsArray = Array.from(tabsBtns);
						const idx = tabsArray.indexOf(target);
						if (idx === -1) return;

						if (isScrollTab) {
							// 스크롤 연동 탭 클릭 시 스크롤 이동 트리거 및 상태 갱신
							scrollState.isScrollingByClick = true;
							scrollState.scrollTargetIdx = idx;

							const pane = tabPanes[idx];
							const paneRect = pane.getBoundingClientRect();
							const scrollY = window.scrollY || window.pageYOffset;
							const offset = UI.common.getOffsetHeight('header'); // fixed header 높이 보정 포함
							const targetY = paneRect.top + scrollY - tabsHeight - offset; // 탭 높이만큼 오프셋 보정

							// 스크롤 이동 전 활성화
							// this.activateTab(tabsBtns, tabPanes, idx, tabIndicator, true);
							// this.slideToSwiper(swiperInstance, idx);
							
							UI.common.scrollToWithCallback(targetY, 500, () => {
								// 스크롤 이동 후 활성화
								this.activateTab(tabsBtns, tabPanes, idx, tabIndicator, true);
								this.slideToSwiper(swiperInstance, idx);

								if (typeof window.onTabScrollComplete === 'function') {
									window.onTabScrollComplete(idx, pane);
								}

								// 스크롤 상태 초기화
								scrollState.isScrollingByClick = false;
								scrollState.scrollTargetIdx = null;
							});
						} else {
							// 일반 탭 클릭 시 즉시 탭 활성화
							this.activateTab(tabsBtns, tabPanes, idx, tabIndicator);
							this.slideToSwiper(swiperInstance, idx);
						}
					});

					// 스크롤 이벤트를 throttle 적용해서 등록 (스크롤 연동 탭에만)
					if (isScrollTab) {
						window.addEventListener(
							'scroll',
							this.throttle(() => {
								this.handleScrollNavigation(tabsBtns, tabPanes, tabIndicator, scrollState, swiperInstance);
							}, this.THROTTLE_DELAY)
						);
					}
				},

				/**
				 * 스크롤 위치에 따른 탭 활성화 처리 함수
				 * @param {NodeListOf<HTMLElement>} tabsBtns 탭 버튼 리스트
				 * @param {NodeListOf<HTMLElement>} panes 탭 내용 패널 리스트
				 * @param {HTMLElement|null} tabIndicator 하단 활성 표시 요소
				 * @param {Object} scrollState 스크롤 상태 객체
				 * @param {Swiper|null} swiperInstance swiper 인스턴스 (추가)
				 */
				handleScrollNavigation(tabsBtns, panes, tabIndicator, scrollState, swiperInstance) {
					const { isScrollingByClick, scrollTargetIdx } = scrollState;
					const tabsEl = tabsBtns[0].closest('.tab').querySelector('.tab_container');
					const tabsHeight = tabsEl ? tabsEl.offsetHeight : 0;

					// 클릭에 의한 스크롤 이동 중이면, 목표 위치 근처 도달 여부 체크
					if (isScrollingByClick && scrollTargetIdx !== null) {
						const pane = panes[scrollTargetIdx];
						const paneTop = pane.getBoundingClientRect().top;
						if (Math.abs(paneTop - tabsHeight) <= this.SCROLL_THRESHOLD) {
							// 목표 위치 도달하면 스크롤 이동 상태 초기화
							scrollState.isScrollingByClick = false;

							// swiper도 해당 탭으로 슬라이드 이동 추가
							this.slideToSwiper(swiperInstance, scrollTargetIdx);

							// 외부 콜백 함수 호출 (존재 시)
							if (typeof window.onTabScrollComplete === 'function') {
								window.onTabScrollComplete(scrollTargetIdx, pane);
							}

							scrollState.scrollTargetIdx = null;
							// 탭 활성화 상태 재설정 (aria 등 갱신)
							this.activateTab(tabsBtns, panes, scrollTargetIdx, tabIndicator, true);
						}
						return; // 클릭 스크롤 중엔 아래 일반 스크롤 처리 로직 건너뜀
					}

					// 클릭 이동이 아닐 때는 현재 스크롤 위치에 가장 가까운 패널 찾기
					let foundIdx = 0;
					let minDiff = Infinity;
					const tabsBottom = tabsEl.getBoundingClientRect().bottom;

					panes.forEach((pane, idx) => {
						const rect = pane.getBoundingClientRect();
						const diff = Math.abs(rect.top - tabsBottom);
						// 탭 하단 근처 위치를 기준으로 가장 가까운 패널 선택
						if (rect.top - tabsBottom <= this.SCROLL_THRESHOLD && diff < minDiff) {
							minDiff = diff;
							foundIdx = idx;
						}
					});

					// 스크롤 위치 기준으로 탭 활성화 갱신
					this.activateTab(tabsBtns, panes, foundIdx, tabIndicator, true);

					// swiper 슬라이드 위치도 갱신 (추가)
					this.slideToSwiper(swiperInstance, foundIdx);
				},
			}
		}

		// DOMContentLoaded 이벤트에 탭 UI 초기화 및 스크롤 완료 콜백 정의
		document.addEventListener('DOMContentLoaded', () => {
			UI.tab.initAll();

			// 스크롤 완료 후 첫 자식 요소에 tabindex 0 부여 및 포커스 이동 (접근성 보완)
			window.onTabScrollComplete = function (tabIndex, pane) {
				const firstTag = pane.firstElementChild;
				if (firstTag) {
					firstTag.setAttribute('tabindex', 0);
					firstTag.focus();
				}
			};
		});
	</script>


</body>

</html>
